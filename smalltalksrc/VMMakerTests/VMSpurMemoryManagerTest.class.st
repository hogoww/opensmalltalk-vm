Class {
	#name : #VMSpurMemoryManagerTest,
	#superclass : #TestCase,
	#instVars : [
		'newSpaceSize',
		'memory',
		'interpreter',
		'oldSpaceSize',
		'nextIndex',
		'objectHeaderSize',
		'zeroSizedObjectClassIndex',
		'emptyObjectSize',
		'initialAddress',
		'stackSpaceSize',
		'stackBuilder',
		'methodCacheSize',
		'rumpCStackSize',
		'wordSize',
		'methodBuilder'
	],
	#pools : [
		'VMBasicConstants',
		'VMBytecodeConstants',
		'VMObjectIndices'
	],
	#category : #'VMMakerTests-MemoryTests'
}

{ #category : #running }
VMSpurMemoryManagerTest >> inSmalltalk: aBlock [
	"easier to ignore only the smalltalk part when creating the call graph"
	^ aBlock value
]

{ #category : #accessing }
VMSpurMemoryManagerTest >> initialCodeSize [
	^ 0
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> initializeOldSpaceForScavenger [

	| freeListOop firstClassTablePage |
	memory coInterpreter bootstrapping: true.

	"Initialize old space with free list, class table, hidden roots and remembered set to be able to scavenge"
	memory initializeFreeList.
	memory segmentManager collapseSegmentsPostSwizzle.
	memory updateFreeLists.
	memory initializeOldSpaceFirstFree: memory freeOldSpaceStart.

	"Create a nil object required to initialize several fields"
	memory nilObject: (self newOldSpaceObjectWithSlots: 0).
	"Create false object required to initialize several fields"
	memory falseObject: (self newOldSpaceObjectWithSlots: 0).
	"Create true object required to initialize several fields"
	memory trueObject: (self newOldSpaceObjectWithSlots: 0).

	"Initialize Stack"
	memory coInterpreter desiredNumStackPages: 8.
	memory coInterpreter initStackPages.

	"Initialize Special Root objects"
	memory coInterpreter method: memory nilObject.
	memory coInterpreter instructionPointer: memory nilObject.
	memory coInterpreter newMethod: memory nilObject.
	memory coInterpreter profileProcess: memory nilObject.
	memory coInterpreter profileMethod: memory nilObject.
	memory coInterpreter profileSemaphore: memory nilObject.
	memory mournQueue: memory nilObject.
	memory specialObjectsOop: memory nilObject.
		
	freeListOop := memory initializeFreeListInOldSpace: true.
	memory initializeFreeSpacePostLoad: freeListOop.
	memory computeFreeSpacePostSwizzle.
		
	memory endOfMemory: memory endOfMemory + memory bridgeSize.
	
	memory initializeOldSpaceFirstFree: (memory addressAfter: freeListOop).
	
	memory allocateClassTable.
	
	firstClassTablePage := memory fetchPointer: 0 ofObject: memory hiddenRootsObject.
	
	memory scavenger initializeRememberedSet.
	memory scavenger remember: memory hiddenRootsObject.
	memory scavenger remember: firstClassTablePage. 
	memory specialObjectsOop: (self newObjectWithSlots: 60).
	
	memory scavengingGCTenuringIf: 1.
	self deny: memory needGCFlag.
]

{ #category : #accessor }
VMSpurMemoryManagerTest >> interpreter [
	<var: #interpreter type: #VMClass>
	<notRealDuplicate>
	^ interpreter
]

{ #category : #running }
VMSpurMemoryManagerTest >> loadPharoImage: fileName [
	<doNotGenerate>
	interpreter openOn: fileName
]

{ #category : #accessor }
VMSpurMemoryManagerTest >> memory [
	<var: #interpreter type: #VMClass>
	<notRealDuplicate>
	^ memory
]

{ #category : #'helpers - classes' }
VMSpurMemoryManagerTest >> newClassInOldSpaceWithSlots: numberOfSlots format: format [
	| newClass formatWithSlots |

	newClass := memory
		allocateSlotsInOldSpace: 3
		format: memory nonIndexablePointerFormat
		classIndex: memory arrayClassIndexPun.
	
	memory storePointer: 0 ofObject: newClass withValue: memory nilObject.
	memory storePointer: 1 ofObject: newClass withValue: memory nilObject.
	
	formatWithSlots := format << 16 + numberOfSlots. 
	memory storePointer: 2 ofObject: newClass withValue: (memory integerObjectOf: formatWithSlots ).
		
	^ newClass	
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> newInterpreter [
	<doNotInfer>
	memory := self newMemory.

	StackInterpreterSimulatorLSB
		initializeWithOptions: {
			#BytesPerWord. self wordSize.
			#ObjectMemory. memory class name}
		objectMemoryClass: memory class.

	^ StackInterpreterSimulatorLSB basicNew
		objectMemory: memory;
		basicInitialize
]

{ #category : #running }
VMSpurMemoryManagerTest >> newMemory [
	<doNotInfer>

	^ self wordSize = 4
		ifTrue: [ Spur32BitMemoryManager simulatorClass new ]
		ifFalse: [ Spur64BitMemoryManager simulatorClass new ]
]

{ #category : #'helpers - methods' }
VMSpurMemoryManagerTest >> newMethodWithSmallContext: isSmall WithArguments: arguments [
	
	| method methodHeader |

	"Create a bytecode compiled method object containing the given literal at the given index"
	
	method := self
		newOldSpaceObjectWithSlots: 0 "# of literals" + 1 "one extra for the header"
		format: (memory compiledMethodFormatForNumBytes: 0)
		classIndex: 16r10.
	methodHeader := (arguments bitShift: 24)
						+ (0 "nTemps" bitShift: 18)
						+ ((isSmall ifTrue: [ 0 "small frame" ] ifFalse: [ 1 "small frame" ]) bitShift: 17)
						+ 0 "number of literaps"
						+ 0 "primitive".
	memory storePointer: 0 ofObject: method withValue: (memory integerObjectOf: methodHeader).

	^ method
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> newObjectWithSlots: slots [
	
	^ self newObjectWithSlots: slots classIndex: memory arrayClassIndexPun
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> newObjectWithSlots: slots classIndex: anIndex [
	
	^ self newObjectWithSlots: slots format: memory arrayFormat classIndex: anIndex
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> newObjectWithSlots: slots format: aFormat classIndex: anIndex [
	
	| oop |
	oop := memory
			allocateSlots: slots
			format: aFormat
			classIndex: anIndex.
	oop ifNotNil: [ memory fillObj: oop numSlots: slots with: memory nilObject ].
	^ oop
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> newOldSpaceObjectWithSlots: slots [
	
	^ self newOldSpaceObjectWithSlots: slots classIndex: memory arrayClassIndexPun
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> newOldSpaceObjectWithSlots: slots classIndex: anIndex [
	
	^ self
		newOldSpaceObjectWithSlots: slots
		format: memory arrayFormat
		classIndex: anIndex
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> newOldSpaceObjectWithSlots: slots format: aFormat classIndex: anIndex [
	
	| oop |
	oop := memory
			allocateSlotsInOldSpace: slots
			format: aFormat
			classIndex: anIndex.
	oop ifNotNil: [ memory fillObj: oop numSlots: slots with: memory nilObject ].
	^ oop
]

{ #category : #'helpers - frames' }
VMSpurMemoryManagerTest >> newSmallContextReceiver: anOop method: aMethodOop arguments: aCollectionOfArgumentsOop temporaries: aCollectionOfTemporariesOop ip: anIp [

	| newCtx numArgs numTemps |
	newCtx := memory eeInstantiateMethodContextSlots: SmallContextSlots.

	numArgs := aCollectionOfArgumentsOop size.
	numTemps := aCollectionOfTemporariesOop size.

	memory storePointerUnchecked: SenderIndex
		ofObject: newCtx
		withValue: memory nilObject.
		
	memory storePointerUnchecked: InstructionPointerIndex
		ofObject: newCtx
		withValue: (memory integerObjectOf: anIp).

	memory storePointerUnchecked: StackPointerIndex
		ofObject: newCtx
		withValue: (memory integerObjectOf: numArgs + numTemps).
		
	memory storePointerUnchecked: MethodIndex
		ofObject: newCtx
		withValue: aMethodOop.

	memory storePointerUnchecked: ClosureIndex ofObject: newCtx withValue: memory nilObject.

	memory storePointerUnchecked: ReceiverIndex
		ofObject: newCtx
		withValue: anOop.
	
	1 to: numArgs do:
		[:i|
		memory storePointerUnchecked: ReceiverIndex + i
			ofObject: newCtx
			withValue: (aCollectionOfArgumentsOop at: i)].

	1 to: numTemps do:
			[:i|
			memory storePointerUnchecked: ReceiverIndex + i + numArgs
				ofObject: newCtx
				withValue: (aCollectionOfTemporariesOop at: i)].
	
	^ newCtx
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> newString: aString [
	| vmString |
	vmString := self
		newOldSpaceObjectWithSlots: aString size
		format: memory firstByteFormat
		classIndex: ByteString hash.

	aString
		doWithIndex: [ :char :index | 
			memory
				storeByte: index - 1
				ofObject: vmString
				withValue: char asInteger ].

	^ vmString
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> newZeroSizedObject [
	
	^ memory
		allocateNewSpaceSlots: 0
		format: 0 "zero sized object"
		classIndex: self zeroSizedObjectClassIndex.
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> nextOrdinaryClassIndex [
	
	^ nextIndex
		ifNil: [ nextIndex := memory classTablePageSize ]
		ifNotNil: [ nextIndex := nextIndex + 1 ]
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> primitiveTraceLogSize [
	^ 0
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> roundToPageSize: anInteger [ 

	"Unicorn simulator requires mapped memory to be multiple of 4096"
	| pageSize remainder |
	pageSize := 4096.
	remainder := anInteger \\ pageSize.
	remainder = 0 ifTrue: [ ^ anInteger ].

	^ anInteger + (pageSize - remainder)
]

{ #category : #running }
VMSpurMemoryManagerTest >> setUp [
	<var: #interpreter type: #VMClass>
	<var: #memory type: #VMClass>
	"This is an alternate setUp using an image to correctly initialize memory/interpreter.
	Currently not used by default, as some tests still fails, but is usable.
	For example, we could test that all test are working on both a specific setup, and image load one.
	Or we could design tests using the image setUp, which should have everything ready to use, and do the specific on after, to refine the requirements of a setUp for a test."

	self inSmalltalk: [
		
		interpreter := self newInterpreter 
			pluginList: { } ; yourself.
		stackBuilder := VMStackBuilder new
			interpreter: interpreter; 
			memory: memory;
			yourself.
				
		methodBuilder := VMMethodBuilder new
			interpreter: interpreter; 
			memory: memory;
			yourself.
		].
		
	"You currently have to setup the path by hand, I do not rememeber/know how to get the directory from a repository, to do a correct relative path
	Sorry :3"
	self loadPharoImage: 'tempConversion-64.image'.
	interpreter initStackPages.
	interpreter loadInitialContext.
	
	objectHeaderSize := 8 "bytes. Always.".
	emptyObjectSize := objectHeaderSize + 8 "minimum required single empty slot, to use for forwarders".
	
	newSpaceSize := memory oldSpaceStart - memory newSpaceStart.
		
]

{ #category : #running }
VMSpurMemoryManagerTest >> setUpScheduler [
	
	"The ScheduleAssocation should be initialized to a valid Processor object"
	| processorOopAssociation processorOop processorListArray processorListPriority1 processorListPriority2 |
	processorOopAssociation := self newObjectWithSlots: 2.
	processorOop := self newObjectWithSlots: 2.
	processorListArray := self newObjectWithSlots: 2.
	
	processorListPriority1 := self newObjectWithSlots: 2.
	processorListPriority2 := self newObjectWithSlots: 2.
	
	memory storePointer: 0 ofObject: processorListArray withValue: processorListPriority1. 
	memory storePointer: 1 ofObject: processorListArray withValue: processorListPriority2.
	
	memory splObj: SchedulerAssociation put: processorOopAssociation.
	memory storePointer: ValueIndex ofObject: processorOopAssociation withValue: processorOop.
	memory storePointer: ProcessListsIndex ofObject: processorOop withValue: processorListArray.
	memory lastHash: 1
]

{ #category : #running }
VMSpurMemoryManagerTest >> setUpSpecific [
	<var: #interpreter type: #VMClass>
	<var: #memory type: #VMClass>
	super setUp.

	"100 k at least to put the class table in the old space.
	Get total size be a multiple of 4K so Unicorn CPU emulator accepts it"
	oldSpaceSize := 999 * 1024.
 	newSpaceSize := 1 * 1024.
	stackSpaceSize := 9 * 4096.
	methodCacheSize := 4096 * 8 "wordSize".
	rumpCStackSize := 0.
	
	initialAddress := 16r1000000.
	
	objectHeaderSize := 8 "bytes. Always.".
	emptyObjectSize := objectHeaderSize + 8 "minimum required single empty slot, to use for forwarders".
	
	"Set it to bootstrapping to allow smaller memories"
	self cCode: [] inSmalltalk:[
		interpreter := self newInterpreter.
		memory := interpreter objectMemory.
	
		memory coInterpreter: interpreter.
		interpreter objectMemory: memory
	].
	
	memory bootstrapping: true.
	
	memory
		allocateMemoryOfSize: oldSpaceSize
		newSpaceSize: newSpaceSize
		stackSize: stackSpaceSize
		codeSize: self initialCodeSize
		methodCacheSize: methodCacheSize
		primitiveTraceLogSize: (self roundToPageSize: self primitiveTraceLogSize)
		rumpCStackSize: rumpCStackSize
		initialAddress: initialAddress.
	memory initializePostBootstrap.
	memory setHeapSizeAtPreviousGC.
	memory segmentManager collapseSegmentsPostSwizzle.
	
	"Schedule a GC, so it does not try to schedule one"
	memory needGCFlag: 1.
	
	stackBuilder := VMStackBuilder new
		interpreter: interpreter; 
		memory: memory;
		yourself.
				
	methodBuilder := VMMethodBuilder new
		interpreter: interpreter; 
		memory: memory;
		yourself.

]

{ #category : #running }
VMSpurMemoryManagerTest >> setUpUsingImage [

	"This is an alternate setUp using an image to correctly initialize memory/interpreter.
	Currently not used by default, as some tests still fails, but is usable.
	For example, we could test that all test are working on both a specific setup, and image load one.
	Or we could design tests using the image setUp, which should have everything ready to use, and do the specific on after, to refine the requirements of a setUp for a test."
	super setUp.
	self cCode: [] inSmalltalk: [
		
		interpreter := self newInterpreter 
			pluginList: { } ; yourself.
		stackBuilder := VMStackBuilder new
			interpreter: interpreter; 
			memory: memory;
			yourself.
				
		methodBuilder := VMMethodBuilder new
			interpreter: interpreter; 
			memory: memory;
			yourself.
		].
		
	"You currently have to setup the path by hand, I do not rememeber/know how to get the directory from a repository, to do a correct relative path
	Sorry :3"
	interpreter openOn: 'tempConversion-64'.
	interpreter initStackPages.
	interpreter loadInitialContext.
	
	objectHeaderSize := 8 "bytes. Always.".
	emptyObjectSize := objectHeaderSize + 8 "minimum required single empty slot, to use for forwarders".
	
	newSpaceSize := memory oldSpaceStart - memory newSpaceStart.
	oldSpaceSize := memory oldSpaceSize.
		
]

{ #category : #accessing }
VMSpurMemoryManagerTest >> sizeOfObjectWithSlots: slots [

	^ objectHeaderSize + ((slots min: 1 "at least one for the forwarder pointer") * memory wordSize "bytes")
]

{ #category : #running }
VMSpurMemoryManagerTest >> wordSize [
	<notRealDuplicate>
	^ wordSize ifNil: [ 8 ]
]

{ #category : #helpers }
VMSpurMemoryManagerTest >> zeroSizedObjectClassIndex [

	^ zeroSizedObjectClassIndex ifNil: [ self nextOrdinaryClassIndex ]
]
